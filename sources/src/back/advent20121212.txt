Garbage Collection Advent Calendar 2012 12/01
###############################################################################

Scavenger(CopyGC)
===============================================================================

Dart VMは世代別GCを採用しており、そのNew領域を管理するScavenger(CopyGC)の説明です。

heapの生成箇所 ::

  Heap::Heap() {
    ...
    new_space_ = new Scavenger(this, ...)
    old_space_ = new PageSpace(this, ...)
    ...
  }

  Heap::~Heap() {
    delete new_space_;
    delete old_space_;
  }

Allocateの起点 ::

  // Heap.h
  Heap::AllocateNew(size) {
    uward addr = new_space_->TryAllocate(size); <-- Newへ領域確保
    if (addr != 0) {                            <-- 成功したら、アドレスを返す。
      return addr;
    }
    CollectGarbage(kNew)                        <-- NewのAllocateに失敗したらGC
    addr = new_space_->TryAllocate(size);
    if (addr != 0) {
      return addr;
    }
    return AllocateOld(size, HeapPage::kData);  <-- 再度失敗したらOld領域に確保
  }

Scavenger領域確保
===============================================================================

Scavengerの管理する領域は、VirtualMemoryにより、mmapでmax_capacity分領域確保します。

その後、2分割してfrom領域とto領域とし、CopyGCを行います。

from領域とto領域へのポインタは、CopyGCのたびに入れ替えます。

Scavengerの管理領域 ::

  VirtualMemory* space_;
  MemoryRegion * from_;
  MemoryRegion * to_;
  Heap* heap_;

Scavengerの領域管理 ::

  Scavenger::Scavenger(Heap* heap, intptr_t max_capacity, uword object_alignment) {
    ...
    space_ = VirtualMemory::Reserve(max_capacity);
    ...
    uword semi_space_size = space_->size() / 2;
    to_ = new MemoryRegion(space_->address(), semi_space_size);
    uword middle = space_->start() + semi_space_size;
    from_ = new MemoryRegion(reinterpret_cast<void*>(middle), semi_space_size);
    // Setup local fields.
    top_ = FirstObjectStart();                    //toの先頭をさします。
    resolved_top_ = top_;
    end_ = to_->end();
    ...
  }

  Scavenger::~Scavenger() {
    delete to_;
    delete from_;
    delete space_;
  }

Allocateする際は、主にtop(to領域の先頭)から順に割り付けていきます。

New領域のTryAllocate() ::

  uword TryAllocate(intptr_t size) {
    ASSERT(Utils::IsAligned(size, kObjectAlignment));
    uword result = top_;
    intptr_t remaining = end_ - top_;
    if (remaining < size) {
      return 0;
    }
    ASSERT(to_->Contains(result));
    ASSERT((result & kObjectAlignmentMask) == object_alignment_);

    top_ += size;
    ASSERT(to_->Contains(top_) || (top_ == to_->end()));
    return result;
  }

TryAllocateには、AssemblerMacroで書かれた特殊版もあるのですが、ここでは割愛。

Scavengerの主なクラス
===============================================================================

主なクラス ::

  // New領域の管理
  class Scavenger(Heap*, intptr_t max_capacity, uword object_alignment)
  // CopyGCのVisitor。Isolateが、全参照のRootを持つ。
  class ScavengerVisitor(Isolate*, Scavenger*)
  // Weak参照の、CopyGCのVisitor、普通に使って入れば出てこないはず。
  class ScavengerWeakVisitor(Scavenger*)

ScavengerはCopyGCであり、オブジェクトのコピーと参照の張替えにforwardingを使用します。

forwarding ::

  // vm/raw_object.h
  private:                                               // RawObjectの先頭はtags_になっています。
    uword tags_;  // Various object tags (bits).         // ForwardToで潰す。
  static RawObject* FromAddr(uword addr) {
    // We expect the untagged address here.
    ASSERT((addr & kSmiTagMask) != kHeapObjectTag);
    return reinterpret_cast<RawObject*>(addr + kHeapObjectTag);
  }
  static uword ToAddr(RawObject* raw_obj) {
    return reinterpret_cast<uword>(raw_obj->ptr());
  }
  RawObject* ptr() const {
    ASSERT(IsHeapObject());
    return reinterpret_cast<RawObject*>(
    reinterpret_cast<uword>(this) - kHeapObjectTag);
  }

  // vm/scavenger.cc
  enum {
    kForwardingMask = 1,
    kNotForwarded = 0,
    kForwarded = 1,
  };

  static inline void ForwardTo(uword orignal, uword target) {
    // Make sure forwarding can be encoded.
    ASSERT((target & kForwardingMask) == 0);
    *reinterpret_cast<uword*>(orignal) = target | kForwarded; // forwarded flagは最下位1bit
  }

  tatic inline bool IsForwarding(uword header) {
    uword bits = header & kForwardingMask;
    ASSERT((bits == kNotForwarded) || (bits == kForwarded));
    return bits == kForwarded;                                // 最下位bitが立っていたらisforwarding
  }

  static inline uword ForwardedAddr(uword header) {
    ASSERT(IsForwarding(header));
    return header & ~kForwardingMask;                         // 最下位bitを0にして返す。
  }

オブジェクトの領域確保には、従来のTryAllocate()を使用し、
オブジェクトをmemmoveを使用してコピーします。

参照の張り替えにForwardedAddr()、参照張り替え済みかのチェックにIsForwarding()、
参照張り替え後のアドレス取得にForwardedAddr()を使用します。

Scavenger::Scavenge()
===============================================================================
Scavenger(CopyGC)のメイン処理です。

大きく分けると、以下の4つです。

- Prologue, Epilogue
- ScavengerVisitor
- ScavengerWeakVisitor        // WeakReferenceはここでは割愛
- ProcessPeerRefenrets

Scavenger::Scavenge() ::

  // Setup the visitor and run a scavenge
  ScavengerVisitor visitor(isolate, this);
  // Prologue処理
  Prologue(isolate, invoke_api_callbacks);
    // from_領域へのポインタとto_領域へのポインタをswapします。
    // from領域から、to領域へ生きているオブジェクトを移動するためです。
    swap from_ <=> to_

  //Isolateのrootから、visit
  IterateRoots(isolate, &visitor, !invoke_api_callbacks);
    IterateStoreBuffer(isolate, visitor)                      // テクニカルな処理
      isolate->store_buffer()->DedupSets()を走査する。        // GC本のV8 記憶集合更新を参照
        RawObject** pointer = ...                             // Old領域からNew領域を参照するポインタ集合を特別に処理する。
        if (IsHeapObject(*pointer)) {
          visitor->VisitPointer(pointer)                      //ScavengerVisitor
            ScavengePointer()
        }
      isolate->store_buffer_block()を走査する。
        RawObject** pointer = ...
        if (IsHeapObject(*pointer)) {
          visitor->VisitPointer(pointer)                      //ScavengerVisitor
            ScavengePointer()
        }
    isolate->VisitObjectPointers(visitor,...)                 // ここが重要。isolateがもつ各種Rootからポインタを辿る。
      ... 各種rootからvisitor叩く
        visitor->VisitPointer(pointer)                        //ScavengerVisitor
          ScavengePointer()
  ProcessToSpace(&visitor);
    // VisitPointers()により、副作用がある。なくなるまで繰り返す。
    while(delayed_weak_stack->isEmpty() || resolve_top  < top || PromotedStackHasMore()) {
      resolved_top_ から topまで走査
        if (! kWeakPropertyCid) {
          resolved_top_ += raw_obj->VisitPointers(visitor);
        } else {                                                   // WeakPropertyの詳細な発生条件はわからない
          resolved_top_ += ProcessWeakProperty(raw_weak, visitor); // DartAPIにWeakPropertyを生成する処理が用意されている。
        }
      //set VisitingOldPointersAddr
      PromotedStackを走査
        raw_object->visitPointers(visitor);
    }
  // ここにWeakRefenrece関連の処理があるが、省略。
  ...
  //WeakVisitor
  // WeakVisitorの処理も省略。IsoalteのApiState()からWeakReferenceを辿る。
  visitor.Finalize(); //WeakPropertyのクリア
  //Epilogue
  ProcessPeerReferents();
  Epilogue(isolate, invoke_api_callbacks);
    survivor_end_ = top_;  // CopyGCで生き残ったオブジェクトを移動した後の境界を記録します。
    // 以後、to領域のSuvivorの後ろから、順にAllocateされていきます。

ポイントとなる処理
===============================================================================

様々なvisitorによってオブジェクトをたどりますが、
各オブジェクトのポインタを処理するのは、ScavengePointer()になります。

ScavengePointerの対象は、すべてRawObjectを継承したクラスになります。

code ::

  ScavengePointer(RawObject** p) {
    // Smi or old heap object
    if (!row_obj->IsHeapObject() || raw_obj->IsOldObject()) {
      return;
    }
    uword raw_addr = RawObject::ToAddr(raw_obj);
    // from領域に存在しない場合、return
    // containsは、アドレスの大小比較のみ。
    if (!scavenger_->from_->contains(raw_addr)) {
      return ;
    }
    uword header = *reinterpret_cast<uword*>(raw_addr); //raw_objの先頭フィールドget
    uword new_addr = 0;
    if (IsForwarding(header)) {
      new_addr = ForwardedAddr(header);
    } else {
      //WeakReference関連の処理。
      if (raw_obj->IsWatched()) {
        ...
      }
      // 前回のCopyGCでsurviveしたオブジェクトでない場合、普通にコピー
      if (survivor_end <= raw_addr) {
        new_addr = scavenger_->TryAllocate(size);       // 普通に領域確保。後で参照張替え
      } else {
        // 前回のCopyGCでsurviveしたものは、Oldへpromotion
        // Copyの生存回数は1回のみ。
        new_addr = heap_->TryAllocate(size, Heap::kOld, growth_policy_);
        if (new_addr != 0) { //Oldへpromoteできたら、PromotedStackに挿入
          scavenger_->PushToPromotedStack(new_addr);
          bytes_promoted_ += size;
        } else if (!had_promotion_failure_) { // promotionに初失敗 ...
          had_promotion_failure_ = true;
          // Old領域を拡張して再度Oldへのpromotionにトライ
          growth_policy = PageSpace::kForceGrowth;
          new_addr = heap_->TryAllocate(size, Heap::kOld, growth_policy_);
          if (new_addr != 0) {
            scavenger_->PushToPromotedStack(new_addr);
            bytes_promoted_ += size;
          } else {
             // Oldに空きがなければ、New領域に確保してみる。
             new_addr = scavenger_->TryAllocate(size);
          }
        } else { // kForceGrowthにしたのに、promotionに再度失敗。Old領域に空きがない。
          // Oldに空きがなければ、New領域に確保してみる。
          new_addr = scavenger_->TryAllocate(size);
        }
      }
      memmove(new_addr, raw_addr, size);   //raw data copy
      ForwardTo(raw_addr, new_addr);       //forwarding addressを記録。参照張替え。
    }
    RawObject* new_obj = RawObject::FromAddr(new_addr);
    *p = new_obj;
    // privateな変数を直参照しているけど、Old領域を走査している場合に限り、trueに切り替わる。
    // trueになるのは、IterateStoreBuffers()と、ProcessToSpace()のPromotedStackHasMore()を走査する間のみ。
    if (visiting_old_pointers_) {
      UpdateStoreBuffer(p, new_obj);
    }
  }

IsolateのVisitObjectPointers()
===============================================================================

走査対象は以下

- ObjectStore
- ClassTable
- StubCode
- current_zone()
- All StackFrame
- ApiState
- top_context    RawContext
- ic_data_array  RrawArray
- debugger

Isolate::VisitObjectPointers()::

    // Visit objects in the object store.
    object_store()->VisitObjectPointers(visitor);

    // Visit objects in the class table.
    class_table()->VisitObjectPointers(visitor);

    // Visit objects in per isolate stubs.
    StubCode::VisitObjectPointers(visitor);

    // Visit objects in zones.
    current_zone()->VisitObjectPointers(visitor);

    // Iterate over all the stack frames and visit objects on the stack.
    StackFrameIterator frames_iterator(validate_frames);
    StackFrame* frame = frames_iterator.NextFrame();
    while (frame != NULL) {
      frame->VisitObjectPointers(visitor);
      frame = frames_iterator.NextFrame();
    }

    // Visit the dart api state for all local and persistent handles.
    if (api_state() != NULL) {
      api_state()->VisitObjectPointers(visitor, visit_prologue_weak_handles);
    }

    // Visit the top context which is stored in the isolate.
    visitor->VisitPointer(reinterpret_cast<RawObject**>(&top_context_));

    // Visit the currently active IC data array.
    visitor->VisitPointer(reinterpret_cast<RawObject**>(&ic_data_array_));

    // Visit objects in the debugger.
    debugger()->VisitObjectPointers(visitor);
  }


ObjectPointerVisitor
===============================================================================

VisitObjectPointers()
===============================================================================

ObjectStore ::

  void ObjectStore::VisitObjectPointers(ObjectPointerVisitor* visitor) {
    ASSERT(visitor != NULL);
      visitor->VisitPointers(from(), to());
  }

ClassTable ::

  void ClassTable::VisitObjectPointers(ObjectPointerVisitor* visitor) {
    ASSERT(visitor != NULL);
      visitor->VisitPointers(reinterpret_cast<RawObject**>(&table_[0]), top_);
  }






===============================================================================
===============================================================================

まとめ
===============================================================================

